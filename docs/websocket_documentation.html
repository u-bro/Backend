<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <h1>WebSocket — Полная документация</h1>

  <div class="section">
    <h2>Краткое описание</h2>
    <p>В этом проекте WebSocket используется для реального времени в следующих сценариях: чат в рамках рейса (ride chat), уведомления, обновление локации водителя и служебные уведомления (broadcast, ping/pong). Документация описывает как подключаться, какие сообщения поддерживаются и как тестировать.</p>
  </div>

  <div class="section">
    <h2>URL подключения</h2>
    <p>WS endpoint (префикс API):</p>
    <pre><code>ws://HOST:PORT/api/v1/chat/ws/{ride_id}?user_id={user_id}&token={access_token}</code></pre>
    <ul>
      <li><strong>HOST:PORT</strong> — например <code>localhost:8000</code> (в compose: host:container = 8000:5000).</li>
      <li><strong>ride_id</strong> — идентификатор рейса (целое число).</li>
      <li><strong>user_id</strong> — идентификатор пользователя (из токена/БД).</li>
      <li><strong>token</strong> — JWT access token, получаемый через <code>POST /api/v1/auth/verify</code>.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Аутентификация</h2>
    <p>Перед подключением получите <code>access_token</code> через flow регистрации/входа и подтверждения кода OTP:</p>
    <pre><code>POST /api/v1/auth/register  or  POST /api/v1/auth/login
      <li>Проверить модерацию: отправить запрещённый текст — убедиться, что сервис блокирует или помечает сообщение согласно правилам в `chat_service`.</li>
    <p>Токен передаётся в query string как <code>token</code> или может быть отправлен в заголовке авторизации для HTTP запросов.</p>
  </div>

  <div class="section">
    <h2>События и форматы сообщений</h2>
    <p>Клиент и сервер обмениваются JSON-сообщениями с полем <code>type</code>. Ниже перечислены поддерживаемые типы.</p>
    <style>
      body{font-family:Inter,Arial,Helvetica,sans-serif;margin:28px;color:#111; font-size:16px; line-height:1.45}
      h1{color:#0b5;font-size:28px;margin-bottom:8px}
      h2{color:#0a5;font-size:20px;margin-top:18px}
      pre{background:#f6f8fa;padding:14px;border-radius:8px;overflow:auto;font-size:15px}
      code{font-family:monospace;font-size:0.98em}
      .section{margin-bottom:20px}
      table{border-collapse:collapse;width:100%;font-size:15px}
      th,td{border:1px solid #ddd;padding:10px;text-align:left;vertical-align:top}
      ul,ol{margin-left:18px}
    </style>
        <tr><td><code>echo</code></td><td>сервер → отправивший</td><td>Эхо входящего полезного тела (используется для тестирования): {type:"echo", message: <raw> }.</td></tr>
        <tr><td><code>ping</code></td><td>клиент → сервер</td><td>Проверка доступности; сервер отвечает <code>{type:"pong"}</code>.</td></tr>
        <tr><td><code>pong</code></td><td>сервер → клиент</td><td>Ответ на ping.</td></tr>
        <tr><td><code>error</code></td><td>сервер → клиент</td><td>Ошибки: {type:"error", code:"...", message:"..."}.</td></tr>
      </tbody>
    </table>
  </div>

  <div class="section">
    <h2>Примеры JavaScript (Browser Console)</h2>
    <pre><code>// подключение
const TOKEN = "&lt;ACCESS_TOKEN&gt;";
const ws = new WebSocket(`ws://localhost:8000/api/v1/chat/ws/2?user_id=3&token=${TOKEN}`);
ws.addEventListener('open', ()=>{ console.log('open'); ws.send(JSON.stringify({text:'Привет', sender_id:3})); });
ws.addEventListener('message', e => console.log('msg', e.data));
ws.addEventListener('close', () => console.log('closed'));

// ping
ws.send(JSON.stringify({type:'ping'}));
</code></pre>
    <p>Рекомендуется ждать события <code>open</code> перед отправкой.</p>
  </div>

  <div class="section">
    <h2>HTTP примеры</h2>
    <p>Отправить сообщение через HTTP (альтернативный путь):</p>
    <pre><code>curl -X POST "http://localhost:8000/api/v1/chat/2/send?sender_id=3" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer &lt;ACCESS_TOKEN&gt;" \
  -d '{"text":"Текст через HTTP"}'</code></pre>

    <p>Получить историю чата:</p>
    <pre><code>curl -H "Authorization: Bearer &lt;ACCESS_TOKEN&gt;" "http://localhost:8000/api/v1/chat/2/history" | jq .</code></pre>
  </div>

  <div class="section">
    <h2>Server-side функции и точки интеграции</h2>
    <ul>
      <li><strong>`app/services/websocket_manager.py`</strong> — `ConnectionManager` управляет подключениями, хранит `active_connections` и `ride_participants`, функции: `connect`, `disconnect`, `send_personal_message`, `send_to_ride`, `broadcast`.</li>
      <li><strong>`app/backend/routers/chat.py`</strong> — WS роут `/chat/ws/{ride_id}`. Обработка входящих сообщений, модерация, rate limit, синхронное сохранение через `chat_service.save_message` и рассылка `new_message`.</li>
      <li><strong>`app/services/chat_service.py`</strong> — `moderate_message`, `check_rate_limit`, `save_message`, `get_chat_history`, `edit_message`, `soft_delete_message`.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Сохранение в базе данных</h2>
    <p>Сообщения сохраняются в таблицу <code>chat_messages</code>. В текущей реализации при получении типа <code>message</code> сервер:</p>
    <ol>
      <li>Проходит модерацию и rate‑limit в <code>chat_service</code>.</li>
      <li>Открывает сессию через <code>async_session_maker()</code> и вызывает <code>chat_service.save_message(...)</code>.</li>
      <li>Выполняет <code>await session.commit()</code> и после этого рассылает событие <code>new_message</code> всем участникам рейса.</li>
    </ol>
    <p>Кусок кода (упрощённо):</p>
    <pre><code>async with async_session_maker() as session:
    message = await chat_service.save_message(
        session=session,
        ride_id=ride_id,
        sender_id=user_id,
        text=filtered_text,
        message_type=message_type,
        is_moderated=True,
    )
    await session.commit()
</code></pre>
    <p>Пример SQL для проверки в Postgres (в контейнере):</p>
    <pre><code>-- все сообщения для рейса 2
SELECT id, ride_id, sender_id, text, created_at
FROM chat_messages
WHERE ride_id = 2
ORDER BY id;

-- количество
SELECT COUNT(*) FROM chat_messages WHERE ride_id = 2;
</code></pre>
    <p>Вы уже можете проверить это командой:</p>
    <pre><code>docker exec -it DEV_POSTGRES psql -U test -d test -c "SELECT id, ride_id, sender_id, text, created_at FROM chat_messages WHERE ride_id = 2 ORDER BY id;"</code></pre>
    <p>Примечание: в будущем можно вынести сохранение в фоновую задачу Celery, но текущая синхронная запись гарантирует, что сообщение получит идентификатор и отметку времени до рассылки.</p>
  </div>

  <div class="section">
    <h2>Схема таблицы `chat_messages` (основные поля)</h2>
    <pre><code>id SERIAL PRIMARY KEY
ride_id INTEGER NOT NULL
sender_id INTEGER NOT NULL
text TEXT
message_type TEXT
attachments JSONB
is_moderated BOOLEAN
created_at TIMESTAMP
edited_at TIMESTAMP
deleted_at TIMESTAMP</code></pre>
    <p>Проверить содержимое в контейнере Postgres:</p>
    <pre><code>docker exec -it DEV_POSTGRES psql -U test -d test -c "SELECT id, ride_id, sender_id, text, created_at FROM chat_messages WHERE ride_id = 2 ORDER BY id;"</code></pre>
  </div>

  <div class="section">
    <h2>Ошибки и как их решать</h2>
    <ul>
      <li><strong>RuntimeError: Expected ASGI message "websocket.send" or "websocket.close", but got 'websocket.accept'"</strong> — возникает при двойном вызове <code>websocket.accept()</code>. Решение: убедиться, что accept вызывается только в одном месте (в данном проекте — в `manager.connect`).</li>
      <li><strong>Соединение закрывается сразу после открытия</strong> — смотрите логи контейнера `WEB_APP`: <code>docker logs WEB_APP --tail 200</code> и ищите строки `WS received raw` / `echo` / `new_message` / ошибки валидации токена.</li>
      <li><strong>Проблемы с Docker image</strong> — при сборке потребовалось обновить базовый образ в `Dockerfile` (пример: `python:3.13-bookworm`).</li>
    </ul>
  </div>

  <div class="section">
    <h2>Пошаговый тестовый сценарий (коротко)</h2>
    <ol>
      <li>Запустить сервисы: <code>docker compose up -d</code> (в проекте порт 8000 проксирует 5000 внутри контейнера).</li>
      <li>Зарегистрировать пользователя и получить OTP → подтвердить → получить <code>access_token</code>.</li>
      <li>Открыть Browser Console и подключиться к WS, ждать <code>connected</code>, отправить сообщение, убедиться в <code>new_message</code>.</li>
      <li>Проверить историю сообщений через HTTP или напрямую в БД.</li>
    </ol>
  </div>

  <div class="section">
    <h2>Quick demo (минимальный набор команд)</h2>
    <p>Короткая последовательность для демонстрации работы чата:</p>
    <ol>
      <li>Запустить сервисы: <code>docker compose up -d</code>.</li>
      <li>Зарегистрировать/войти: <code>POST /api/v1/auth/register</code> или <code>/auth/login</code>, затем <code>POST /api/v1/auth/verify</code> — получить <code>access_token</code>.</li>
      <li>Открыть Browser Console и выполнить JS‑snippet для подключения WS (ожидать <code>connected</code>).</li>
      <li>Отправить сообщение из Console или из второй вкладки — убедиться, что оба клиента получают <code>new_message</code>.</li>
      <li>Проверить историю: <code>curl -H "Authorization: Bearer &lt;ACCESS_TOKEN&gt;" "http://localhost:8000/api/v1/chat/2/history" | jq .</code></li>
    </ol>
  </div>

  <div class="section">
    <h2>Swagger ↔ Документация (соответствие)</h2>
    <table>
      <thead><tr><th>Swagger</th><th>Описание / WS</th></tr></thead>
      <tbody>
        <tr><td><code>GET /api/v1/ws/stats</code></td><td>Административная статистика WebSocket сервиса (не чат).</td></tr>
        <tr><td><code>POST /api/v1/ws/broadcast</code></td><td>Broadcast нотификации — server→clients.</td></tr>
        <tr><td><code>POST /api/v1/ws/driver/{user_id}/location</code></td><td>Обновление локации водителя (альтернативный HTTP путь к WS‑функциям).</td></tr>
        <tr><td><code>ws://HOST:PORT/api/v1/chat/ws/{ride_id}</code></td><td>Chat WebSocket — основной endpoint для ride chat (используйте query <code>?user_id=&token=</code>).</td></tr>
        <tr><td><code>POST /api/v1/chat/{ride_id}/send</code></td><td>HTTP API для отправки сообщения (эквивалентно WS message).</td></tr>
      </tbody>
    </table>
  </div>

  <div class="section">
    <h2>Примеры attachments и возможные message_type</h2>
    <p>Поле <code>attachments</code> хранит JSON с информацией о вложениях. Пример:</p>
    <pre><code>{
  "attachments": [
    {"type": "image", "url": "https://.../img.jpg", "width": 1024, "height": 768},
    {"type": "file", "url": "https://.../doc.pdf", "name": "receipt.pdf"}
  ]
}
</code></pre>
    <p>Рекомендуемые значения <code>message_type</code> (проектно): <code>"text"</code>, <code>"image"</code>, <code>"system"</code>, <code>"file"</code>. Сервер в текущей реализации принимает строку и сохраняет её в поле <code>message_type</code>.</p>
  </div>

  <div class="section">
    <h2>Дополнения и следующее улучшение</h2>
    <ul>
      <li>Добавить параметр <code>forward_to_ride_id</code> в формат сообщения — сервер после сохранения дополнительно рассылает сообщение в другую комнату.</li>
      <li>Вынести сохранение сообщений в фоновую задачу Celery для устойчивости при высокой нагрузке.</li>
      <li>Покрыть тестами rate limit, модерацию и баги с авторизацией WS.</li>
    </ul>
  </div>
    </ol>
  </div>

  <div class="section">
    <h2>Workaround: fallback через SMS (краткий гайд)</h2>
    <ul>
      <li>Сценарий: если push/WS недоступен (плохая сеть у клиента), отправляем критические нотификации через SMS.</li>
      <li>Подход: генерируем уведомление синхронно при важных переходах (accept/assigned) и ставим в очередь для отправки через отдельный Celery task (<code>tasks/notifications.send_sms</code>).</li>
      <li>Практическая команда (пример): <code>POST /api/v1/notifications/sms</code> с payload {'phone': '+7...', 'text': 'Ваш заказ принят'}. В demo — подготовьте тестовый SMS‑провайдер или логгер, чтобы не расходовать реальные SMS.</li>
      <li>Рекомендация: в проде — использовать delivery status и retry в Celery; для демо можно логировать в файл и показать, что запись на отправку создана.</li>
    </ul>
  </div>
</body>
</html>
