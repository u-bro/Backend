<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chat API — HTTP + WebSocket</title>
  <style>
    body{font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;margin:24px;color:#111;line-height:1.5}
    h1,h2,h3{color:#0b63a3}
    section{margin-bottom:18px}
    pre{background:#f6f8fa;padding:12px;border-radius:6px;overflow:auto}
    code{background:#f3f4f6;padding:2px 4px;border-radius:4px}
    .note{background:#fff7e6;border:1px solid #ffd591;padding:10px;border-radius:6px}
    .ok{background:#f6ffed;border:1px solid #b7eb8f;padding:10px;border-radius:6px}
    ul{margin:6px 0 12px 20px}
    table{border-collapse:collapse;width:100%;margin:8px 0}
    th,td{border:1px solid #e5e7eb;padding:8px;vertical-align:top}
    th{background:#f9fafb;text-align:left}
  </style>
</head>
<body>
  <h1>Chat API — HTTP + WebSocket</h1>
  <p>
    Этот документ описывает работу модуля чата: HTTP-эндпоинты (<code>ChatHttpRouter</code>) и WebSocket-эндпоинт
    (<code>ChatWebsocketRouter</code>). Цель — чтобы сторонний читатель быстро понял:
    как подключаться, как отправлять сообщения, как работает аутентификация и какие события приходят от сервера.
  </p>

  <section>
    <h2>1) Компоненты и маршруты</h2>
    <p>В приложении роутер разделён на два файла:</p>
    <ul>
      <li><strong>HTTP</strong>: <code>app/backend/routers/chat_http.py</code></li>
      <li><strong>WebSocket</strong>: <code>app/backend/routers/chat_ws.py</code></li>
    </ul>

    <p>Все пути ниже указаны с учётом общего префикса API:</p>
    <pre><code>API_PREFIX = /api/v1</code></pre>

    <div class="note">
      <strong>Важно:</strong> в HTTP-запросах сессия БД создаётся middleware и доступна как <code>request.state.session</code>.
      Для WebSocket-соединений сессия создаётся вручную на время соединения (<code>async_session_maker</code>).
    </div>
  </section>

  <section>
    <h2>2) Аутентификация и доступ</h2>

    <h3>2.1 HTTP (Authorization header)</h3>
    <p>
      HTTP-эндпоинты используют зависимость <code>get_current_user_id</code>, которая достаёт JWT из заголовка
      <code>Authorization: Bearer &lt;access_token&gt;</code>.
    </p>
    <pre><code>Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...</code></pre>

    <h3>2.2 WebSocket (token в query или Authorization header)</h3>
    <p>
      WebSocket-эндпоинт использует зависимость <code>get_current_user_id_ws</code>.
      Токен можно передать:
    </p>
    <ul>
      <li><strong>в query</strong>: <code>?token=&lt;access_token&gt;</code> (удобно для Postman/браузера)</li>
      <li><strong>в заголовке</strong>: <code>Authorization: Bearer &lt;access_token&gt;</code> (удобно для мобильных клиентов/серверов)</li>
    </ul>

    <pre><code>ws://HOST/api/v1/chat/ws/{ride_id}?token=ACCESS_TOKEN</code></pre>

    <h3>2.3 Проверка доступа к чату поездки</h3>
    <p>
      На подключении WS и при работе HTTP предполагается ограничение доступа: пользователь должен быть участником поездки.
      В текущей реализации это проверяется через <code>chat_service.verify_ride_user(session, ride_id, user_id)</code>.
    </p>
    <ul>
      <li><strong>Клиент</strong>: <code>Ride.client_id == user_id</code></li>
      <li><strong>Водитель</strong>: <code>Ride.driver_profile.user_id == user_id</code> (если водитель назначен)</li>
    </ul>

    <div class="note">
      <strong>Примечание:</strong> если соединение отклоняется до <code>accept()</code>, сервер может вернуть только код закрытия
      (например, 1008) без подробного текста. Некоторые клиенты (например, Postman) не всегда показывают <em>close reason</em>.
      Для гарантированной диагностики можно принимать соединение и отправлять JSON-ошибку перед закрытием.
    </div>
  </section>

  <section>
    <h2>3) HTTP API: эндпоинты</h2>

    <table>
      <thead>
        <tr>
          <th>Метод</th>
          <th>Путь</th>
          <th>Назначение</th>
          <th>Аутентификация</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>GET</code></td>
          <td><code>/api/v1/chat/{ride_id}/history</code></td>
          <td>История сообщений по поездке (пагинация по <code>before_id</code>)</td>
          <td><code>Authorization: Bearer ...</code></td>
        </tr>
        <tr>
          <td><code>POST</code></td>
          <td><code>/api/v1/chat/{ride_id}/send</code></td>
          <td>Отправка сообщения через HTTP (сохранение в БД + broadcast в WS room поездки)</td>
          <td><code>Authorization: Bearer ...</code></td>
        </tr>
        <tr>
          <td><code>DELETE</code></td>
          <td><code>/api/v1/chat/{ride_id}/message/{message_id}</code></td>
          <td>Мягкое удаление своего сообщения (soft delete)</td>
          <td><code>Authorization: Bearer ...</code></td>
        </tr>
        <tr>
          <td><code>PUT</code></td>
          <td><code>/api/v1/chat/{ride_id}/message/{message_id}</code></td>
          <td>Редактирование своего сообщения</td>
          <td><code>Authorization: Bearer ...</code></td>
        </tr>
        <tr>
          <td><code>GET</code></td>
          <td><code>/api/v1/chat/stats</code></td>
          <td>Статистика сервиса (rate limit, модерация, и т.п.)</td>
          <td>Не требует</td>
        </tr>
      </tbody>
    </table>

    <h3>3.1 GET history</h3>
    <p>Query-параметры:</p>
    <ul>
      <li><code>limit</code> (1..100, default 50)</li>
      <li><code>before_id</code> (optional) — для постраничного просмотра истории</li>
    </ul>

    <pre><code>GET /api/v1/chat/2/history?limit=50&amp;before_id=123
Authorization: Bearer &lt;token&gt;</code></pre>

    <h3>3.2 POST send</h3>
    <p>Тело запроса (<code>SendMessageRequest</code>):</p>
    <pre><code>{
  "text": "Привет!",
  "message_type": "text",
  "receiver_id": null,
  "attachments": null
}</code></pre>

    <p>Ответ (<code>SendMessageResponse</code>):</p>
    <pre><code>{
  "id": 101,
  "ride_id": 2,
  "sender_id": 1,
  "text": "Привет!",
  "message_type": "text",
  "is_moderated": true,
  "created_at": "2025-12-29T18:40:12.123Z",
  "moderation_note": null
}</code></pre>

    <div class="ok">
      <strong>Важно:</strong> при успешной отправке через HTTP сервер также рассылает событие
      <code>new_message</code> всем участникам поездки, которые подключены по WebSocket.
    </div>
  </section>

  <section>
    <h2>4) WebSocket: подключение и протокол сообщений</h2>

    <h3>4.1 Подключение</h3>
    <pre><code>WS: /api/v1/chat/ws/{ride_id}

Пример:
ws://api.dev.u-bro.ru/api/v1/chat/ws/2?token=ACCESS_TOKEN</code></pre>

    <h3>4.2 События сервера при подключении</h3>
    <p>После подключения сервер отправляет:</p>
    <ul>
      <li><code>user_joined</code> (broadcast в комнату поездки для других участников)</li>
      <li><code>connected</code> (лично подключившемуся)</li>
    </ul>

    <pre><code>// connected
{
  "type": "connected",
  "ride_id": 2,
  "user_id": 1,
  "message": "Connected to chat"
}</code></pre>

    <h3>4.3 Формат входящих сообщений от клиента</h3>
    <p>Все сообщения — JSON. Базовое поле:</p>
    <ul>
      <li><code>type</code> — тип сообщения</li>
    </ul>

    <p>Если <code>type</code> отсутствует, сервер трактует сообщение как <code>message</code>.</p>

    <table>
      <thead>
        <tr>
          <th>type</th>
          <th>Назначение</th>
          <th>Пример</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>ping</code></td>
          <td>Проверка соединения</td>
          <td><pre><code>{"type":"ping"}</code></pre></td>
        </tr>
        <tr>
          <td><code>typing</code></td>
          <td>Сигнал “пользователь печатает” (рассылается другим участникам)</td>
          <td><pre><code>{"type":"typing"}</code></pre></td>
        </tr>
        <tr>
          <td><code>message</code></td>
          <td>Отправка сообщения в чат</td>
          <td><pre><code>{
  "type": "message",
  "text": "Я подъехал",
  "message_type": "text",
  "receiver_id": null,
  "attachments": null
}</code></pre></td>
        </tr>
      </tbody>
    </table>

    <h3>4.4 События сервера</h3>
    <table>
      <thead>
        <tr>
          <th>type</th>
          <th>Когда приходит</th>
          <th>Пример payload</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>pong</code></td>
          <td>Ответ на <code>ping</code></td>
          <td><pre><code>{"type":"pong"}</code></pre></td>
        </tr>
        <tr>
          <td><code>user_typing</code></td>
          <td>Кто-то печатает</td>
          <td><pre><code>{
  "type": "user_typing",
  "ride_id": 2,
  "user_id": 1,
  "timestamp": "..."
}</code></pre></td>
        </tr>
        <tr>
          <td><code>new_message</code></td>
          <td>Новое сообщение сохранено и разослано</td>
          <td><pre><code>{
  "type": "new_message",
  "message": {
    "id": 101,
    "ride_id": 2,
    "sender_id": 1,
    "text": "Я подъехал",
    "message_type": "text",
    "is_moderated": true,
    "created_at": "...",
    "censored": false
  },
  "timestamp": "..."
}</code></pre></td>
        </tr>
        <tr>
          <td><code>error</code></td>
          <td>Ошибки протокола/валидации</td>
          <td><pre><code>{
  "type": "error",
  "code": "rate_limit",
  "message": "Rate limit exceeded..."
}</code></pre></td>
        </tr>
      </tbody>
    </table>

    <div class="note">
      <strong>Unknown message type:</strong> базовый роутер (<code>BaseWebsocketRouter</code>) вернёт
      JSON-ошибку вида <code>{"type":"error","message":"Unknown message type: ..."}</code>, если отправить неизвестный <code>type</code>.
    </div>
  </section>

  <section>
    <h2>5) Rate limit и модерация</h2>

    <h3>5.1 Rate limit</h3>
    <p>
      На уровне <code>chat_service.check_rate_limit(user_id)</code> введено ограничение:
      максимум <code>10</code> сообщений за <code>60</code> секунд (значения задаются в <code>ChatService</code>).
    </p>

    <h3>5.2 Модерация текста</h3>
    <p>
      Перед сохранением сообщения выполняется модерация: фильтрация нецензурных слов (включая leet/замены).
      Если текст содержит запрещённые слова — он цензурируется. В событии <code>new_message</code>
      присутствует поле <code>censored</code>, если исходный текст был изменён.
    </p>
  </section>

  <section>
    <h2>6) Практические примеры</h2>

    <h3>6.1 Тест WebSocket через Postman</h3>
    <ol>
      <li>Получить access token через <code>/auth/send</code> → <code>/auth/verify</code>.</li>
      <li>Подключиться к WS:
        <pre><code>ws://HOST/api/v1/chat/ws/2?token=ACCESS_TOKEN</code></pre>
      </li>
      <li>Отправить ping:
        <pre><code>{"type":"ping"}</code></pre>
      </li>
      <li>Отправить сообщение:
        <pre><code>{"type":"message","text":"Привет","message_type":"text"}</code></pre>
      </li>
    </ol>

    <h3>6.2 Тест HTTP send + WS broadcast</h3>
    <ol>
      <li>Оставить открытым WS-соединение на <code>/chat/ws/{ride_id}</code>.</li>
      <li>Отправить HTTP:
        <pre><code>POST /api/v1/chat/2/send
Authorization: Bearer ACCESS_TOKEN

{"text":"Сообщение через HTTP","message_type":"text"}</code></pre>
      </li>
      <li>Убедиться, что по WS прилетело событие <code>new_message</code>.</li>
    </ol>
  </section>

  <footer>
    <p>Файл: <code>docs/chat.html</code></p>
  </footer>
</body>
</html>
